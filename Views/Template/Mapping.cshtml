@model CTOM.ViewModels.Template.TemplateMappingViewModel
@using System.Text.Json;
@using System.Text.Json.Serialization;
@{
    ViewData["Title"] = "Ánh xạ trường dữ liệu (Mapping)";
    var jsonOptions = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };
}

@* Phần Header của trang (Không thay đổi) *@
<div class="page-header d-print-none">
    <div class="container-xl">
        <div class="row g-2 align-items-center">
            <div class="col">
                <h2 class="page-title">
                    <i class="ti ti-vector-bezier-2 me-2"></i>Ánh xạ trường dữ liệu (Mapping)
                </h2>
                <div class="text-muted mt-1">
                    Template: @Model.TemplateName
                </div>
                <div class="mapping-instruction">
                    <i class="ti ti-info-circle me-1"></i>
                    <strong>Hướng dẫn:</strong> Click chọn vị trí trong tài liệu, sau đó bấm nút<button type="button" class="btn btn-sm btn-outline-primary ms-1" title="Chèn"><i class="ti ti-arrow-right"></i></button> để chèn thêm placeholder.<br>
                    <ul class="mb-0 mt-1">
                        <li>Không thể chỉnh sửa nội dung tài liệu gốc để đảm bảo ánh xạ chính xác.</li>
                        @if (ViewData["MaxTableNestingLevel"] != null)
                        {
                            <li>Bảng lồng ghép tối đa @ViewData["MaxTableNestingLevel"] cấp.</li>
                        }
                    </ul>
                </div>
            </div>
            <div class="col-auto ms-auto d-print-none">
                 <a href="@Url.Action("Index")" class="btn btn-outline-secondary">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                        <path d="M9 11l-4 4l4 4m-4 -4h11a4 4 0 0 0 0 -8h-1"></path>
                    </svg>
                    Quay lại
                </a>
                <button type="button" class="btn btn-primary" id="saveMappingBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-device-floppy"><path stroke="none" d="M0 0h24v24H0z" fill="none" /><path d="M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" /><path d="M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" /><path d="M14 4l0 4l-6 0l0 -4" /></svg>
                    Lưu thay đổi
                </button>
            </div>
        </div>
    </div>
</div>

@* Phần thân trang với layout 3 cột (Không thay đổi cấu trúc HTML) *@
<div class="page-body">
    <div class="main-layout">
        <!-- Cột trái: Danh sách các trường dữ liệu có sẵn -->
        <div class="sidebar card">
            <div class="card-header">
                <ul class="nav nav-tabs card-header-tabs nav-fill" role="tablist" id="fieldsTabNav">
                    <li class="nav-item" role="presentation">
                        <a href="#cif" class="nav-link active" role="tab">Trường CIF</a>
                    </li>
                    <li class="nav-item" role="presentation">
                        <a href="#custom" class="nav-link" role="tab">Trường tùy biến</a>
                    </li>
                </ul>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div class="p-3 border-bottom">
                    <div id="cif-search-group">
                        <input type="text" class="form-control" placeholder="Tìm kiếm trường CIF..." id="searchField">
                    </div>
                    <div id="custom-search-group" class="d-none">
                        <div class="input-group">
                            <input type="text" class="form-control" placeholder="Tìm kiếm trường..." id="searchCustomField">
                            <button type="button" class="btn btn-sm btn-success ms-2 rounded" id="showCreateFieldModalBtn" title="Tạo trường mới">
                                <i class="ti ti-plus"></i> Tạo mới
                            </button>
                        </div>
                    </div>
                </div>
                <div class="field-list-wrapper" id="fieldsListContainer">
                    @* Danh sách sẽ được render hoàn toàn bằng JavaScript *@
                </div>
            </div>
        </div>

        <!-- Cột giữa: Xem trước tài liệu -->
        <div class="content-panel card">
            <div class="card-header py-2">
                <div class="card-title mb-0">Nội dung tài liệu</div>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div id="document-preview" class="flex-grow-1 p-4" contenteditable="true">
                    @if (!string.IsNullOrEmpty(Model.StructuredHtmlContent))
                    {
                        @Html.Raw(Model.StructuredHtmlContent)
                    }
                    else
                    {
                        <div class="empty-placeholder">
                            <i class="ti ti-file-off"></i>
                            <p>Không có nội dung tài liệu để hiển thị.</p>
                        </div>
                    }
                </div>
            </div>
        </div>

        <!-- Cột phải: Các trường đã chèn -->
        <div class="sidebar card">
            <div class="card-header py-2">
                <div class="card-title mb-0">Trường đã chèn</div>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div class="p-2 border-bottom d-flex justify-content-between align-items-center">
                    <div class="small text-muted">Tổng số: <span id="insertedFieldsCount">0</span></div>
                    <button type="button" class="btn btn-sm btn-outline-danger" id="clearAllFields">
                        <i class="ti ti-trash"></i> Xóa hết
                    </button>
                </div>
                <div class="flex-grow-1 overflow-auto" id="insertedFieldsList">
                    @* Render bằng JS *@
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modals (Không thay đổi) -->
<div class="modal fade" id="createFieldModal" tabindex="-1" aria-labelledby="createFieldModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createFieldModalLabel">Tạo trường dữ liệu tùy biến</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="createCustomFieldForm">
                    <div class="mb-3">
                        <label for="modalFieldName" class="form-label required">Tên trường</label>
                        <input type="text" id="modalFieldName" class="form-control" placeholder="VD: SoTienDeNghi (viết liền, không dấu)" required>
                        <small class="form-hint">Không chứa khoảng trắng hoặc ký tự đặc biệt.</small>
                    </div>
                    <div class="mb-3">
                        <label for="modalDisplayName" class="form-label required">Tên hiển thị (trên form)</label>
                        <input type="text" id="modalDisplayName" class="form-control" placeholder="VD: Số tiền đề nghị" required>
                    </div>
                    <div class="mb-3">
                        <label for="modalDataType" class="form-label">Kiểu dữ liệu</label>
                        <select id="modalDataType" class="form-select">
                            <option value="TEXT">TEXT (Một dòng)</option>
                            <option value="TEXTAREA">TEXTAREA (Nhiều dòng)</option>
                            <option value="NUMBER">NUMBER (Số)</option>
                            <option value="DATE">DATE (Ngày tháng)</option>
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" data-bs-dismiss="modal">Hủy</button>
                <button type="button" class="btn btn-primary" id="saveCustomFieldBtn">Lưu</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="customModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            <div class="modal-status bg-primary"></div>
            <div class="modal-body text-center py-4">
                <i id="modalIcon" class="ti ti-info-circle" style="font-size: 3rem;"></i>
                <h4 id="modalTitle" class="mt-2">Thông báo</h4>
                <div id="modalMessage" class="text-muted"></div>
            </div>
            <div class="modal-footer d-flex">
                 <button id="modalCancelBtn" type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
                 <button id="modalConfirmBtn" type="button" class="btn btn-primary">Đồng ý</button>
            </div>
        </div>
    </div>
</div>
<div class="modal" id="loadingModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-sm modal-dialog-centered" role="document">
        <div class="modal-content">
            <div class="modal-body text-center py-4">
                <div class="spinner-border text-primary mb-3" role="status"></div>
                <h3>Đang lưu...</h3>
                <div class="text-muted">Vui lòng chờ trong giây lát.</div>
            </div>
        </div>
    </div>
</div>

@section Styles {
    <link href="~/css/template/mapping.css" rel="stylesheet" />
    <style>
        /* CSS động để tô màu bảng lồng nhau (Không thay đổi) */
        @{
            var maxNestingLevel = (int)(ViewData["MaxTableNestingLevel"] ?? 1);
            var maxAllowedDepth = maxNestingLevel + 1;
            var allowedBorderColors = new[] { "#28a745", "#0d6efd", "#6f42c1" };
            var allowedBgColors = new[] { "#f8fff9", "#f4f8ff", "#f8f5ff" };
        }
        @for (var level = 0; level <= maxNestingLevel; level++)
        {
            var depth = level + 2;
            if (level >= allowedBorderColors.Length) { continue; }
            <text>
            #document-preview .nested-table[data-nested-depth="@depth"] { border: 2px solid @(allowedBorderColors[level]) !important; background-color: @(allowedBgColors[level]) !important; }
            #document-preview .nested-table[data-nested-depth="@depth"] td { background-color: @(allowedBgColors[level]) !important; }
            </text>
        }
        @{
            var disallowedSelectors = new List<string>();
            for (int i = maxAllowedDepth + 1; i <= 10; i++) { disallowedSelectors.Add($"#document-preview .nested-table[data-nested-depth=\"{i}\"]"); }
        }
        @if(disallowedSelectors.Any())
        {
            <text>
            @(string.Join(",\n", disallowedSelectors)) { border: 2px solid #dc3545 !important; background-color: #fff5f5 !important; }
            @(string.Join(" td,\n", disallowedSelectors)) td { background-color: #fff5f5 !important; }
            </text>
        }
        #document-preview [data-mappable="true"]:hover { background-color: #e3f2fd !important; cursor: pointer; }
    </style>
}

@section Scripts {
<script>
document.addEventListener('DOMContentLoaded', function () {
    const allAvailableFields = @Html.Raw(JsonSerializer.Serialize(Model.AvailableFields, jsonOptions));
    const availableFieldsMap = new Map(allAvailableFields.map(f => [f.name, f]));

    const App = {
        state: {
            templateId: @Model.TemplateId,
            maxTableNestingLevel: @(ViewData["MaxTableNestingLevel"] ?? 1),
            mappedFields: new Map(),
            insertedFields: new Set(),
            customFields: [],
            activeTab: 'cif',
            lastSelection: null,
            createFieldModal: null,
            loadingModal: null
        },

        elements: {
            docPreview: null, saveBtn: null,
            fieldsListContainer: null,
            insertedList: null, insertedCount: null,
            tabNav: null, cifSearchGroup: null, customSearchGroup: null,
            cifSearchInput: null, customSearchInput: null
        },

        // --- INIT & SETUP ---
        init() {
            console.log("App initializing with Hybrid Fingerprinting & Full UI...");
            this.bindElements();
            this.modal.init(); 
            this.setupEventListeners();
            this.protection.init();
            this.loadCustomFieldsFromAvailable();
            this.renderActiveTabList();
            this.loadInitialMappings();
            this.updateInsertedFieldsUI();
            this.initTooltips();
            console.log("App initialized successfully.");
        },
        
        bindElements() {
            this.elements.docPreview = document.getElementById('document-preview');
            this.elements.saveBtn = document.getElementById('saveMappingBtn');
            this.elements.fieldsListContainer = document.getElementById('fieldsListContainer');
            this.elements.insertedList = document.getElementById('insertedFieldsList');
            this.elements.insertedCount = document.getElementById('insertedFieldsCount');
            this.elements.tabNav = document.getElementById('fieldsTabNav');
            this.elements.cifSearchGroup = document.getElementById('cif-search-group');
            this.elements.customSearchGroup = document.getElementById('custom-search-group');
            this.elements.cifSearchInput = document.getElementById('searchField');
            this.elements.customSearchInput = document.getElementById('searchCustomField');
            this.state.createFieldModal = new bootstrap.Modal(document.getElementById('createFieldModal'));
            this.state.loadingModal = new bootstrap.Modal(document.getElementById('loadingModal'));
        },
        
        loadCustomFieldsFromAvailable() {
            this.state.customFields = allAvailableFields.filter(f => f.dataSourceType === 'FORM');
        },

        loadInitialMappings() {
            try {
                const initialData = JSON.parse('@Html.Raw(Model.MappedFieldsJson)');
                if (Array.isArray(initialData) && initialData.length > 0) {
                    for (const field of initialData) {
                        const positionsWithUiId = field.positions.map(p => ({...p, uiId: crypto.randomUUID() }));
                        this.state.mappedFields.set(field.fieldName, {
                            displayName: field.displayName,
                            positions: positionsWithUiId
                        });
                        this.state.insertedFields.add(field.fieldName);
                    }
                    this.restorePlaceholdersOnUI();
                }
            } catch (error) { console.error("Lỗi khi khôi phục mapping:", error); }
        },

        setupEventListeners() {
            document.body.addEventListener('click', this.handleGlobalClick.bind(this));
            
            this.elements.tabNav.addEventListener('click', (e) => {
                const targetLink = e.target.closest('a.nav-link');
                if (targetLink && !targetLink.classList.contains('active')) {
                    e.preventDefault();
                    this.state.activeTab = targetLink.getAttribute('href').substring(1);
                    this.elements.tabNav.querySelectorAll('a.nav-link').forEach(a => a.classList.remove('active'));
                    targetLink.classList.add('active');
                    this.elements.cifSearchGroup.classList.toggle('d-none', this.state.activeTab !== 'cif');
                    this.elements.customSearchGroup.classList.toggle('d-none', this.state.activeTab !== 'custom');
                    this.renderActiveTabList();
                }
            });

            this.elements.cifSearchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
            this.elements.customSearchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));

            document.addEventListener('selectionchange', () => {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && this.elements.docPreview.contains(selection.anchorNode)) {
                    this.state.lastSelection = selection.getRangeAt(0).cloneRange();
                }
            });
        },
        
        // --- UI RENDERING ---
        renderActiveTabList() {
            const searchTerm = (this.state.activeTab === 'cif' ? this.elements.cifSearchInput.value : this.elements.customSearchInput.value).toLowerCase();
            let fieldsToRender = this.state.activeTab === 'cif'
                ? allAvailableFields.filter(f => f.dataSourceType === 'CIF')
                : this.state.customFields;

            if (searchTerm) {
                fieldsToRender = fieldsToRender.filter(f => 
                    f.name.toLowerCase().includes(searchTerm) || 
                    (f.displayName && f.displayName.toLowerCase().includes(searchTerm))
                );
            }
            
            const listHtml = fieldsToRender.length > 0
                ? fieldsToRender.map(field => this.createFieldItemHtml(field)).join('')
                : '<div class="p-4 text-center text-muted">Không có trường nào.</div>';

            this.elements.fieldsListContainer.innerHTML = listHtml;
        },

        handleSearch(term) {
            this.renderActiveTabList();
        },

        createFieldItemHtml(field) {
            const dataTypeUpper = (field.dataType || "TEXT").toUpperCase();
            let iconClass = "ti ti-abc text-muted";
            if (dataTypeUpper.includes("DATE")) { iconClass = "ti ti-calendar-event text-danger"; }
            else if (dataTypeUpper.includes("NUMBER")) { iconClass = "ti ti-number-123 text-success"; }
            
            const dataSourceBadge = field.dataSourceType ? `<span class="badge bg-${field.dataSourceType === 'CIF' ? 'primary' : 'yellow'}-lt d-block mt-1">${field.dataSourceType}</span>` : '';

            return `
                <div class="field-item p-2 border-bottom" data-field-name="${field.name}" data-display-name="${field.displayName}">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="field-item-display">
                            <div style="text-align:center; width: 40px;">
                                <i class="${iconClass} field-data-type-icon" title="${field.dataType}"></i>
                                ${dataSourceBadge}
                            </div>
                            <div class="field-item-info">
                                <div class="fw-bold field-item-name" title="${field.name}">${field.name}</div>
                                <div class="text-muted small" title="${field.displayName}">${field.displayName ?? field.name}</div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary insert-field-btn" data-field-code="${field.name}" data-field-name="${field.displayName}" title="Chèn">
                            <i class="ti ti-arrow-right"></i>
                        </button>
                    </div>
                </div>`;
        },
        
        updateInsertedFieldsUI() {
            this.elements.insertedCount.textContent = this.state.insertedFields.size;
            if (this.state.insertedFields.size === 0) {
                this.elements.insertedList.innerHTML = `<div class="p-4 text-center text-muted">Chưa có trường nào.</div>`;
                return;
            }
            let html = '<div class="list-group list-group-flush">';
            Array.from(this.state.insertedFields).sort().forEach(fieldName => {
                const fieldData = this.state.mappedFields.get(fieldName);
                const count = fieldData ? fieldData.positions.length : 0;
                const fieldInfo = availableFieldsMap.get(fieldName);
                const displayName = fieldInfo?.displayName || fieldName;
                const dataType = fieldInfo?.dataType || 'TEXT';
                const dataSourceType = fieldInfo?.dataSourceType || '';
                const iconClass = (dataType.toUpperCase().includes('DATE')) ? 'ti ti-calendar-event text-danger' : (dataType.toUpperCase().includes('NUMBER')) ? 'ti ti-number-123 text-success' : 'ti ti-abc text-muted';
                const dataSourceBadge = dataSourceType ? `<span class="badge bg-${dataSourceType === 'CIF' ? 'primary' : 'yellow'}-lt d-block mt-1">${dataSourceType}</span>` : '';

                html += `
                    <div class="field-item list-group-item p-2">
                        <div class="d-flex align-items-center justify-content-between">
                            <div class="field-item-display">
                                <div style="text-align:center; width: 40px;">
                                    <i class="${iconClass} field-data-type-icon" title="${dataType}"></i>
                                    ${dataSourceBadge}
                                </div>
                                <div class="field-item-info">
                                    <div class="fw-bold field-item-name" title="${fieldName}">${fieldName}</div>
                                    <div class="text-muted small" title="${displayName}">${displayName}</div>
                                </div>
                            </div>
                            <div class="d-flex align-items-center ms-2">
                                <span class="badge bg-secondary-lt me-2">SL: ${count}</span>
                                <button type="button" class="btn btn-sm btn-icon btn-outline-danger btn-remove-field" data-field="${fieldName}" title="Xóa tất cả các lần chèn của trường này">
                                    <i class="ti ti-x"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
            });
            html += '</div>';
            this.elements.insertedList.innerHTML = html;
        },

        // --- EVENT HANDLING ---
        handleGlobalClick(e) {
            const target = e.target;
            const insertBtn = target.closest('.insert-field-btn');
            const removeBtn = target.closest('.btn-remove-field');
            const clearAllBtn = target.closest('#clearAllFields');
            const saveBtn = target.closest('#saveMappingBtn');
            const createBtn = target.closest('#showCreateFieldModalBtn');
            const saveCustomBtn = target.closest('#saveCustomFieldBtn');
            const placeholder = target.closest('.field-placeholder');

            if (insertBtn) {
                const fieldName = insertBtn.dataset.fieldCode;
                const displayName = insertBtn.dataset.fieldName;
                this.handleInsertField(fieldName, displayName);
            } else if (removeBtn) {
                const fieldName = removeBtn.dataset.field;
                this.modal.show({
                    title: 'Xóa trường',
                    message: `Bạn có chắc muốn xóa tất cả các lần chèn của trường <strong>${fieldName}</strong> không?`,
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.removeField(fieldName)
                });
            } else if (clearAllBtn) {
                this.modal.show({
                    title: 'Xóa tất cả?',
                    message: 'Hành động này sẽ xóa tất cả các trường đã chèn. Bạn có chắc không?',
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.removeField(null, true)
                });
            } else if (saveBtn) {
                this.handleSave();
            } else if (createBtn) {
                this.state.createFieldModal.show();
            } else if (saveCustomBtn) {
                this.handleSaveCustomField();
            } else if (placeholder) {
                e.preventDefault(); e.stopPropagation();
                const safeText = this.escapeHtml(placeholder.textContent);
                this.modal.show({
                    title: 'Xóa placeholder?',
                    message: `Bạn có chắc muốn xóa placeholder <strong>${safeText}</strong> này không?`,
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.handleRemovePlaceholder(placeholder)
                });
            }
        },
        
        // --- CORE LOGIC ---

        handleSaveCustomField() {
            const nameInput = document.getElementById('modalFieldName');
            const displayNameInput = document.getElementById('modalDisplayName');
            const dataTypeInput = document.getElementById('modalDataType');

            const name = nameInput.value.trim();
            const displayName = displayNameInput.value.trim();
            const dataType = dataTypeInput.value;

            if (!name || !displayName) {
                this.modal.show({ title: 'Lỗi', message: 'Tên trường và Tên hiển thị là bắt buộc.', type: 'danger' });
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(name)) {
                this.modal.show({ title: 'Lỗi', message: 'Tên trường chỉ được chứa chữ cái, số và dấu gạch dưới, không chứa khoảng trắng.', type: 'danger' });
                return;
            }

            if (availableFieldsMap.has(name)) {
                this.modal.show({ title: 'Lỗi', message: `Tên trường "${name}" đã tồn tại. Vui lòng chọn tên khác.`, type: 'danger' });
                return;
            }

            const newField = {
                name: name,
                displayName: displayName,
                dataType: dataType,
                dataSourceType: 'FORM'
            };

            this.state.customFields.push(newField);
            availableFieldsMap.set(name, newField);
            
            if (this.state.activeTab === 'custom') {
                this.renderActiveTabList();
            }

            this.state.createFieldModal.hide();
            
            nameInput.value = '';
            displayNameInput.value = '';
            dataTypeInput.value = 'TEXT';
        },

        handleInsertField(fieldName, displayName) {
            if (!this.state.lastSelection) {
                this.modal.show({ title: 'Cần chọn vị trí', message: 'Vui lòng chọn vị trí trong tài liệu trước khi chèn placeholder.', type: 'warning' });
                return;
            }
            
            const range = this.state.lastSelection;
            const fingerprint = this.createFingerprintFromRange(range);
            
            if (!fingerprint) {
                this.modal.show({ title: 'Lỗi', message: 'Không thể tạo "dấu vân tay" cho vị trí này. Vui lòng thử lại ở vị trí khác.', type: 'danger' });
                return;
            }

            const maxAllowedDepth = this.state.maxTableNestingLevel + 1;
            if (fingerprint.nestedDepth > maxAllowedDepth) {
                const nestingLevelText = this.state.maxTableNestingLevel == 0 ? "bảng cha" : `bảng lồng tối đa ${this.state.maxTableNestingLevel} cấp`;
                this.modal.show({ title: 'Lỗi', message: `Không thể mapping vào bảng lồng quá sâu. Hệ thống chỉ cho phép mapping vào ${nestingLevelText}.`, type: 'warning' });
                return;
            }

            if (!this.state.mappedFields.has(fieldName)) {
                this.state.mappedFields.set(fieldName, { displayName: displayName, positions: [] });
            }
            this.state.mappedFields.get(fieldName).positions.push(fingerprint);
            this.state.insertedFields.add(fieldName);

            this.insertPlaceholderNode(range, fieldName, displayName, fingerprint.uiId);
            this.updateInsertedFieldsUI();
            this.initTooltips();
        },

        handleRemovePlaceholder(placeholderElement) {
            const fieldName = placeholderElement.dataset.fieldName;
            const uiId = placeholderElement.dataset.uiId;

            const fieldData = this.state.mappedFields.get(fieldName);
            if (fieldData && uiId) {
                fieldData.positions = fieldData.positions.filter(p => p.uiId !== uiId);
                if (fieldData.positions.length === 0) {
                    this.state.mappedFields.delete(fieldName);
                    this.state.insertedFields.delete(fieldName);
                }
            }
            
            const parent = placeholderElement.parentElement;
            placeholderElement.remove();
            parent.normalize();
            this.updateInsertedFieldsUI();
        },
        
        removeField(fieldName, clearAll = false) {
            if (clearAll) {
                this.elements.docPreview.querySelectorAll('.field-placeholder').forEach(el => el.remove());
                this.state.insertedFields.clear();
                this.state.mappedFields.clear();
            } else if (fieldName) {
                this.elements.docPreview.querySelectorAll(`.field-placeholder[data-field-name="${fieldName}"]`).forEach(el => el.remove());
                this.state.insertedFields.delete(fieldName);
                this.state.mappedFields.delete(fieldName);
            }
            this.updateInsertedFieldsUI();
        },

        handleSave() {
            this.modal.show({
                title: 'Xác nhận lưu',
                message: 'Bạn có chắc chắn muốn lưu các thay đổi này không?',
                type: 'primary',
                confirmText: 'Đồng ý',
                showCancel: true,
                onConfirm: () => {
                    // [SỬA ĐỔI] Tách hàm xử lý async ra để tránh lỗi
                    const performSave = async () => {
                        this.state.loadingModal.show();
                        
                        const fieldsPayload = [];
                        for (const [fieldName, fieldData] of this.state.mappedFields.entries()) {
                            const availableField = allAvailableFields.find(f => f.name === fieldName);
                            fieldsPayload.push({
                                fieldName: fieldName,
                                displayName: fieldData.displayName,
                                positions: fieldData.positions,
                                dataType: availableField?.dataType,
                                isRequired: availableField?.isRequired || false,
                                dataSourceType: availableField?.dataSourceType,
                            });
                        }
                        const requestPayload = { templateId: this.state.templateId, fields: fieldsPayload };
                        
                        try {
                            const response = await fetch('@Url.Action("SaveMapping", "Template")', {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                },
                                body: JSON.stringify(requestPayload)
                            });
                            
                            const result = await response.json();
                            
                            // [SỬA ĐỔI] Chờ modal loading ẩn đi rồi mới hiện modal kết quả
                            const loadingModalEl = document.getElementById('loadingModal');
                            loadingModalEl.addEventListener('hidden.bs.modal', () => {
                                if (response.ok && result.success) {
                                    this.modal.show({
                                        title: 'Thành công',
                                        message: result.message,
                                        type: 'success'
                                    });
                                } else {
                                    this.modal.show({
                                        title: 'Lỗi',
                                        message: result.message || 'Lưu thất bại.',
                                        type: 'danger'
                                    });
                                }
                            }, { once: true }); // Quan trọng: chỉ lắng nghe sự kiện một lần

                        } catch (error) {
                             // [SỬA ĐỔI] Xử lý lỗi tương tự
                            const loadingModalEl = document.getElementById('loadingModal');
                            loadingModalEl.addEventListener('hidden.bs.modal', () => {
                                this.modal.show({
                                    title: 'Lỗi nghiêm trọng',
                                    message: 'Đã có lỗi xảy ra: ' + error.message,
                                    type: 'danger'
                                });
                            }, { once: true });
                        } finally {
                            this.state.loadingModal.hide();
                        }
                    };
                    
                    performSave();
                }
            });
        },

        // --- FINGERPRINTING HELPERS ---
        createFingerprintFromRange(range) {
            let { container, offset } = this.normalizeRangeStart(range);
            if (!container) return null;

            const parentElement = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
            if (!parentElement) return null;

            const runSpan = parentElement.closest('span[data-docx-path]');
            const paragraph = parentElement.closest('p[data-paragraph-hash]');
            if (!paragraph) return null;

            const paragraphHash = paragraph.dataset.paragraphHash;
            const structuralPath = runSpan ? runSpan.dataset.docxPath : paragraph.dataset.docxPath;
            const nestedDepth = parseInt(paragraph.dataset.nestedDepth || '0', 10);

            const { fullText, absoluteOffset } = this.getParagraphTextAndAbsoluteOffset(paragraph, container, offset);

            const contextChars = 20;
            const contextBeforeText = fullText.substring(Math.max(0, absoluteOffset - contextChars), absoluteOffset);
            const contextAfterText = fullText.substring(absoluteOffset, absoluteOffset + contextChars);

            return {
                uiId: crypto.randomUUID(),
                paragraphHash,
                contextBeforeText,
                contextAfterText,
                charOffsetInRun: offset,
                structuralPath,
                nestedDepth
            };
        },
        
        normalizeRangeStart(range) {
            let container = range.startContainer;
            let offset = range.startOffset;

            if (container.nodeType !== Node.TEXT_NODE) {
                let targetNode = container;
                if (targetNode.nodeType === Node.ELEMENT_NODE && offset < targetNode.childNodes.length) {
                    targetNode = targetNode.childNodes[offset];
                }

                const walker = document.createTreeWalker(targetNode, NodeFilter.SHOW_TEXT);
                const firstTextNode = walker.nextNode();

                if (firstTextNode) {
                    container = firstTextNode;
                    offset = 0;
                } else {
                    const tempTextNode = document.createTextNode('');
                    range.insertNode(tempTextNode);
                    container = tempTextNode;
                    offset = 0;
                }
            }
            return { container, offset };
        },

        getParagraphTextAndAbsoluteOffset(paragraph, startNode, startOffset) {
            let fullText = '';
            let absoluteOffset = -1;
            
            const walker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT);
            let currentNode;
            
            while (currentNode = walker.nextNode()) {
                if (absoluteOffset === -1 && currentNode === startNode) {
                    absoluteOffset = fullText.length + startOffset;
                }
                fullText += currentNode.textContent;
            }

            if (absoluteOffset === -1 && paragraph.contains(startNode)) {
                 absoluteOffset = fullText.length;
            }

            return { fullText, absoluteOffset };
        },
        
        insertPlaceholderNode(range, fieldName, displayName, uiId) {
            const placeholderEl = document.createElement('span');
            placeholderEl.className = 'field-placeholder';
            placeholderEl.contentEditable = 'false';
            placeholderEl.dataset.fieldName = fieldName;
            placeholderEl.dataset.uiId = uiId;
            placeholderEl.textContent = `<<${fieldName}>>`;
            placeholderEl.dataset.bsToggle = 'tooltip';
            placeholderEl.title = `Click để xóa Field: ${displayName || fieldName}`;

            const startContainer = range.startContainer;
            const existingPlaceholder = startContainer.nodeType === Node.TEXT_NODE 
                ? startContainer.parentElement.closest('.field-placeholder')
                : startContainer.closest('.field-placeholder');

            range.deleteContents();

            if (existingPlaceholder) {
                existingPlaceholder.after(placeholderEl);
            } else {
                range.insertNode(placeholderEl);
            }
            
            const selection = window.getSelection();
            range.setStartAfter(placeholderEl);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        },

        restorePlaceholdersOnUI() {
            const allParagraphs = Array.from(this.elements.docPreview.querySelectorAll('p[data-paragraph-hash]'));

            const findParagraphAndIndex = (fingerprint) => {
                if (fingerprint.paragraphHash && fingerprint.paragraphHash !== '') {
                    const pIndex = allParagraphs.findIndex(p => p.dataset.paragraphHash === fingerprint.paragraphHash);
                    if (pIndex !== -1) {
                        return { paragraph: allParagraphs[pIndex], index: pIndex };
                    }
                }
                if (fingerprint.structuralPath) {
                    const el = this.elements.docPreview.querySelector(`[data-docx-path="${fingerprint.structuralPath}"]`);
                    if (el) {
                        const targetP = el.closest('p[data-paragraph-hash]');
                        if (targetP) {
                            const pIndex = allParagraphs.indexOf(targetP);
                            return { paragraph: targetP, index: pIndex };
                        }
                    }
                }
                return { paragraph: null, index: -1 };
            };
            
            for (const [fieldName, fieldData] of this.state.mappedFields.entries()) {
                const sortedPositions = [...fieldData.positions].sort((a, b) => {
                    const posA = findParagraphAndIndex(a);
                    const posB = findParagraphAndIndex(b);

                    if (posB.index !== posA.index) return posB.index - posA.index;

                    if (posA.index === -1) return 0;
                    const pA = posA.paragraph;

                    const { fullText: fullTextA } = this.getParagraphTextAndAbsoluteOffset(pA, document.body, 0);
                    const insertionIndexA = this.findAbsoluteOffsetInText(fullTextA, a);

                    const { fullText: fullTextB } = this.getParagraphTextAndAbsoluteOffset(pA, document.body, 0);
                    const insertionIndexB = this.findAbsoluteOffsetInText(fullTextB, b);

                    return insertionIndexB - insertionIndexA;
                });

                for (const fingerprint of sortedPositions) {
                    const { paragraph: targetParagraph } = findParagraphAndIndex(fingerprint);

                    if (targetParagraph) {
                        const position = this.findNodeAndOffsetFromFingerprint(targetParagraph, fingerprint);
                        if (position.node) {
                            const range = document.createRange();
                            range.setStart(position.node, position.offset);
                            this.insertPlaceholderNode(range, fieldName, fieldData.displayName, fingerprint.uiId);
                        } else {
                            console.warn("Không tìm thấy vị trí node để khôi phục placeholder:", fieldName, fingerprint);
                        }
                    } else {
                         console.warn("Không tìm thấy paragraph để khôi phục placeholder:", fieldName, fingerprint);
                    }
                }
            }
        },
        
        findAbsoluteOffsetInText(fullText, fingerprint) {
            if (fullText.trim().replace(/\u00A0/g, '') === '' && fingerprint.contextBeforeText === '' && fingerprint.contextAfterText === '') {
                return 0;
            }
            let searchStr = fingerprint.contextBeforeText + fingerprint.contextAfterText;
            if (searchStr) {
                let index = fullText.indexOf(searchStr);
                if (index !== -1) {
                    return index + fingerprint.contextBeforeText.length;
                }
            }
            if(fingerprint.contextBeforeText) {
                let index = fullText.lastIndexOf(fingerprint.contextBeforeText);
                if(index !== -1) return index + fingerprint.contextBeforeText.length;
            }
            if(fingerprint.contextAfterText) {
                let index = fullText.indexOf(fingerprint.contextAfterText);
                if(index !== -1) return index;
            }
            if (fingerprint.contextBeforeText === '' && fingerprint.contextAfterText === '') {
                return 0;
            }
            return -1;
        },

        findNodeAndOffsetFromFingerprint(paragraph, fingerprint) {
            if (fingerprint.paragraphHash === '' && !paragraph.textContent.trim().replace(/\u00A0/g, '')) {
                let textNode = Array.from(paragraph.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
                if (!textNode) {
                    textNode = document.createTextNode('');
                    paragraph.prepend(textNode);
                }
                return { node: textNode, offset: 0 };
            }

            const { fullText } = this.getParagraphTextAndAbsoluteOffset(paragraph, document.body, 0);
            const absoluteOffset = this.findAbsoluteOffsetInText(fullText, fingerprint);
            
            if (absoluteOffset === -1) {
                console.warn("Không tìm thấy vị trí bằng context trong paragraph có nội dung.", fingerprint);
                return { node: null, offset: -1 };
            }

            const walker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT);
            let cumulativeOffset = 0;
            let currentNode;
            while (currentNode = walker.nextNode()) {
                const nodeLength = currentNode.textContent.length;
                if (cumulativeOffset + nodeLength >= absoluteOffset) {
                    const offsetInNode = absoluteOffset - cumulativeOffset;
                    return { node: currentNode, offset: offsetInNode };
                }
                cumulativeOffset += nodeLength;
            }

            const allTextNodes = [];
            const treeWalker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT);
            while(treeWalker.nextNode()) allTextNodes.push(treeWalker.currentNode);
            
            const lastTextNode = allTextNodes.pop();

            if(lastTextNode) {
                 return { node: lastTextNode, offset: lastTextNode.textContent.length };
            }

            return { node: null, offset: -1 };
        },

        // --- UTILITIES ---
        initTooltips() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(el => {
                const instance = bootstrap.Tooltip.getInstance(el);
                if (instance) instance.dispose();
                new bootstrap.Tooltip(el);
            });
        },
        escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        },

        modal: {
            instance: null,
            titleEl: null,
            messageEl: null,
            iconEl: null,
            confirmBtn: null,
            cancelBtn: null,
            onConfirmCallback: null,

            init() {
                const modalEl = document.getElementById('customModal');
                if (!modalEl) return;
                this.instance = new bootstrap.Modal(modalEl);
                this.titleEl = document.getElementById('modalTitle');
                this.messageEl = document.getElementById('modalMessage');
                this.iconEl = document.getElementById('modalIcon');
                this.confirmBtn = document.getElementById('modalConfirmBtn');
                this.cancelBtn = document.getElementById('modalCancelBtn');

                this.confirmBtn.addEventListener('click', () => {
                    if (typeof this.onConfirmCallback === 'function') {
                        this.onConfirmCallback();
                    }
                    this.instance.hide();
                });
            },

            show({ title, message, type = 'primary', confirmText = 'OK', showCancel = false, onConfirm = null }) {
                this.titleEl.textContent = title;
                this.messageEl.innerHTML = message;
                
                this.iconEl.className = `ti mb-2 text-${type}`;
                if (type === 'danger') this.iconEl.classList.add('ti-alert-triangle');
                else if (type === 'success') this.iconEl.classList.add('ti-check');
                else this.iconEl.classList.add('ti-info-circle');

                this.confirmBtn.textContent = confirmText;
                this.confirmBtn.className = `btn`;
                if(!showCancel) this.confirmBtn.classList.add('w-100');
                this.confirmBtn.classList.add(`btn-${type}`);
                
                this.cancelBtn.style.display = showCancel ? 'block' : 'none';

                this.onConfirmCallback = onConfirm;
                
                this.instance.show();
            }
        },
        
        protection: {
            warningTimeout: null,
            
            init() {
                const docPreview = App.elements.docPreview;
                if (!docPreview) return;

                docPreview.addEventListener('keydown', (e) => {
                    const allowedKeys = [
                        'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
                        'Home', 'End', 'PageUp', 'PageDown', 'Tab', 'Escape'
                    ];
                    if (e.ctrlKey && (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'c')) {
                        return;
                    }
                    
                    if (!allowedKeys.includes(e.key)) {
                        e.preventDefault();
                        this.showEditWarning();
                    }
                });
                
                docPreview.addEventListener('paste', (e) => { 
                    e.preventDefault(); 
                    this.showEditWarning();
                });
                
                docPreview.addEventListener('drop', (e) => { 
                    e.preventDefault(); 
                    this.showEditWarning();
                });
            },

            showEditWarning() {
                const docPreview = App.elements.docPreview;
                docPreview.style.backgroundColor = '#fff3cd';
                docPreview.style.outline = '2px solid #ffeaa7';

                clearTimeout(this.warningTimeout);
                this.warningTimeout = setTimeout(() => {
                    docPreview.style.backgroundColor = '';
                    docPreview.style.outline = '';
                }, 500);
            }
        }
    };

    App.init();
});
</script>
}
