@model CTOM.ViewModels.Template.TemplateMappingViewModel
@using System.Text.Json;
@using System.Text.Json.Serialization;
@{
    ViewData["Title"] = "Ánh xạ trường dữ liệu (Mapping)";
    var jsonOptions = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };
}

@* Phần Header của trang (Không thay đổi) *@
<div class="page-header d-print-none">
    <div class="container-xl">
        <div class="row g-2 align-items-center">
            <div class="col">
                <h2 class="page-title">
                    <i class="ti ti-vector-bezier-2 me-2"></i>Ánh xạ trường dữ liệu (Mapping)
                </h2>
                <div class="text-muted mt-1">
                    Template: @Model.TemplateName
                </div>
                <div class="mapping-instruction">
                    <i class="ti ti-info-circle me-1"></i>
                    <strong>Hướng dẫn:</strong> Click chọn vị trí trong tài liệu, sau đó bấm nút<button type="button" class="btn btn-sm btn-outline-primary ms-1" title="Chèn"><i class="ti ti-arrow-right"></i></button> để chèn thêm placeholder.<br>
                    <ul class="mb-0 mt-1">
                        <li>Không thể chỉnh sửa nội dung tài liệu gốc để đảm bảo ánh xạ chính xác.</li>
                    </ul>
                </div>
            </div>
            <div class="col-auto ms-auto d-print-none">
                 <a href="@Url.Action("Index")" class="btn btn-outline-secondary">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                        <path d="M9 11l-4 4l4 4m-4 -4h11a4 4 0 0 0 0 -8h-1"></path>
                    </svg>
                    Quay lại
                </a>
                <button type="button" class="btn btn-primary" id="saveMappingBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-device-floppy"><path stroke="none" d="M0 0h24v24H0z" fill="none" /><path d="M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" /><path d="M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" /><path d="M14 4l0 4l-6 0l0 -4" /></svg>
                    Lưu thay đổi
                </button>
            </div>
        </div>
    </div>
</div>

@* Phần thân trang với layout 3 cột (Không thay đổi cấu trúc HTML) *@
<div class="page-body">
    <div class="main-layout">
        <!-- Cột trái: Danh sách các trường dữ liệu có sẵn -->
        <div class="sidebar card">
            <div class="card-header">
                <ul class="nav nav-tabs card-header-tabs nav-fill" role="tablist" id="fieldsTabNav">
                    <li class="nav-item" role="presentation">
                        <a href="#cif" class="nav-link active" role="tab">Trường CIF</a>
                    </li>
                    <li class="nav-item" role="presentation">
                        <a href="#custom" class="nav-link" role="tab">Trường tùy biến</a>
                    </li>
                </ul>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div class="p-3 border-bottom">
                    <div id="cif-search-group">
                        <input type="text" class="form-control" placeholder="Tìm kiếm trường CIF..." id="searchField">
                    </div>
                    <div id="custom-search-group" class="d-none">
                        <div class="input-group">
                            <input type="text" class="form-control" placeholder="Tìm kiếm trường..." id="searchCustomField">
                            <button type="button" class="btn btn-sm btn-success ms-2 rounded" id="showCreateFieldModalBtn" title="Tạo trường mới">
                                <i class="ti ti-plus"></i> Tạo mới
                            </button>
                        </div>
                    </div>
                </div>
                <div class="field-list-wrapper" id="fieldsListContainer">
                    @* Danh sách sẽ được render hoàn toàn bằng JavaScript *@
                </div>
            </div>
        </div>

        <!-- Cột giữa: Xem trước tài liệu -->
        <div class="content-panel card">
            <div class="card-header py-2">
                <div class="card-title mb-0">Nội dung tài liệu</div>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div id="document-preview" class="flex-grow-1 p-4" contenteditable="true">
                    @if (!string.IsNullOrEmpty(Model.StructuredHtmlContent))
                    {
                        @Html.Raw(Model.StructuredHtmlContent)
                    }
                    else
                    {
                        <div class="empty-placeholder">
                            <i class="ti ti-file-off"></i>
                            <p>Không có nội dung tài liệu để hiển thị.</p>
                        </div>
                    }
                </div>
            </div>
        </div>

        <!-- Cột phải: Các trường đã chèn -->
        <div class="sidebar card">
            <div class="card-header py-2">
                <div class="card-title mb-0">Trường đã chèn</div>
            </div>
            <div class="card-body p-0 d-flex flex-column">
                <div class="p-2 border-bottom d-flex justify-content-between align-items-center">
                    <div class="small text-muted">Tổng số: <span id="insertedFieldsCount">0</span></div>
                    <button type="button" class="btn btn-sm btn-outline-danger" id="clearAllFields">
                        <i class="ti ti-trash"></i> Xóa hết
                    </button>
                </div>
                <div class="flex-grow-1 overflow-auto" id="insertedFieldsList">
                    @* Render bằng JS *@
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modals (Không thay đổi) -->
<div class="modal fade" id="createFieldModal" tabindex="-1" aria-labelledby="createFieldModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createFieldModalLabel">Tạo trường dữ liệu tùy biến</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="createCustomFieldForm">
                    <div class="mb-3">
                        <label for="modalFieldName" class="form-label required">Tên trường</label>
                        <input type="text" id="modalFieldName" class="form-control" placeholder="VD: SoTienDeNghi (viết liền, không dấu)" required>
                        <small class="form-hint">Không chứa khoảng trắng hoặc ký tự đặc biệt.</small>
                    </div>
                    <div class="mb-3">
                        <label for="modalDisplayName" class="form-label required">Tên hiển thị (trên form)</label>
                        <input type="text" id="modalDisplayName" class="form-control" placeholder="VD: Số tiền đề nghị" required>
                    </div>
                    <div class="mb-3">
                        <label for="modalDataType" class="form-label">Kiểu dữ liệu</label>
                        <select id="modalDataType" class="form-select">
                            <option value="TEXT">TEXT (Một dòng)</option>
                            <option value="TEXTAREA">TEXTAREA (Nhiều dòng)</option>
                            <option value="NUMBER">NUMBER (Số)</option>
                            <option value="DATE">DATE (Ngày tháng)</option>
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" data-bs-dismiss="modal">Hủy</button>
                <button type="button" class="btn btn-primary" id="saveCustomFieldBtn">Lưu</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="customModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
        <div class="modal-content">
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            <div class="modal-status bg-primary"></div>
            <div class="modal-body text-center py-4">
                <i id="modalIcon" class="ti ti-info-circle" style="font-size: 3rem;"></i>
                <h4 id="modalTitle" class="mt-2">Thông báo</h4>
                <div id="modalMessage" class="text-muted"></div>
            </div>
            <div class="modal-footer d-flex">
                 <button id="modalCancelBtn" type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
                 <button id="modalConfirmBtn" type="button" class="btn btn-primary">Đồng ý</button>
            </div>
        </div>
    </div>
</div>
<div class="modal" id="loadingModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-sm modal-dialog-centered" role="document">
        <div class="modal-content">
            <div class="modal-body text-center py-4">
                <div class="spinner-border text-primary mb-3" role="status"></div>
                <h3>Đang lưu...</h3>
                <div class="text-muted">Vui lòng chờ trong giây lát.</div>
            </div>
        </div>
    </div>
</div>

@section Styles {
    <link href="~/css/template/mapping.css" rel="stylesheet" />
}

@section Scripts {
<script>
document.addEventListener('DOMContentLoaded', function () {
    const allAvailableFields = @Html.Raw(JsonSerializer.Serialize(Model.AvailableFields, jsonOptions));
    const availableFieldsMap = new Map(allAvailableFields.map(f => [f.name, f]));

    const App = {
        state: {
            templateId: @Model.TemplateId,
            // [NÂNG CẤP] Đây là nguồn dữ liệu chính (source of truth), một mảng phẳng chứa tất cả các fingerprint.
            mappedFieldsFingerprints: [], 
            //maxTableNestingLevel: @(ViewData["MaxTableNestingLevel"] ?? 1),
            //mappedFields: new Map(),
            insertedFields: new Set(),
            customFields: [],
            activeTab: 'cif',
            lastSelection: null,
            createFieldModal: null,
            loadingModal: null
        },

        elements: {
            docPreview: null, saveBtn: null,
            fieldsListContainer: null,
            insertedList: null, insertedCount: null,
            tabNav: null, cifSearchGroup: null, customSearchGroup: null,
            cifSearchInput: null, customSearchInput: null
        },

        // --- INIT & SETUP ---
        init() {
            console.log("App initializing with NEW Fingerprinting Logic...");
            this.bindElements();
            this.modal.init(); 
            this.setupEventListeners();
            this.protection.init();
            this.loadCustomFieldsFromAvailable();
            this.renderActiveTabList();
            this.loadInitialMappings(); // [NÂNG CẤP] Logic tải lại mapping đã thay đổi
            this.updateInsertedFieldsUI(); // [NÂNG CẤP] Logic render UI đã thay đổi
            this.initTooltips();
            console.log("App initialized successfully.");
        },
        
        bindElements() {
            this.elements.docPreview = document.getElementById('document-preview');
            this.elements.saveBtn = document.getElementById('saveMappingBtn');
            this.elements.fieldsListContainer = document.getElementById('fieldsListContainer');
            this.elements.insertedList = document.getElementById('insertedFieldsList');
            this.elements.insertedCount = document.getElementById('insertedFieldsCount');
            this.elements.tabNav = document.getElementById('fieldsTabNav');
            this.elements.cifSearchGroup = document.getElementById('cif-search-group');
            this.elements.customSearchGroup = document.getElementById('custom-search-group');
            this.elements.cifSearchInput = document.getElementById('searchField');
            this.elements.customSearchInput = document.getElementById('searchCustomField');
            this.state.createFieldModal = new bootstrap.Modal(document.getElementById('createFieldModal'));
            this.state.loadingModal = new bootstrap.Modal(document.getElementById('loadingModal'));
        },
        
        loadCustomFieldsFromAvailable() {
            this.state.customFields = allAvailableFields.filter(f => f.dataSourceType === 'FORM');
        },

        // [NÂNG CẤP] Tải và khôi phục mapping từ dữ liệu fingerprint mới
        loadInitialMappings() {
            try {
                const initialFingerprints = @Html.Raw(Model.MappedFieldsJson ?? "[]");
                if (Array.isArray(initialFingerprints) && initialFingerprints.length > 0) {
                    // Gán uiId để quản lý trên UI và lưu vào state chính
                    this.state.mappedFieldsFingerprints = initialFingerprints.map(fp => ({
                        ...fp,
                        uiId: crypto.randomUUID() 
                    }));
                    this.restorePlaceholdersOnUI();
                }
            } catch (error) { 
                console.error("Lỗi khi khôi phục mapping:", error); 
                this.state.mappedFieldsFingerprints = [];
            }
        },

        setupEventListeners() {
            // [GIỮ NGUYÊN] Các event listener chính
            document.body.addEventListener('click', this.handleGlobalClick.bind(this));
            
            this.elements.tabNav.addEventListener('click', (e) => {
                const targetLink = e.target.closest('a.nav-link');
                if (targetLink && !targetLink.classList.contains('active')) {
                    e.preventDefault();
                    this.state.activeTab = targetLink.getAttribute('href').substring(1);
                    this.elements.tabNav.querySelectorAll('a.nav-link').forEach(a => a.classList.remove('active'));
                    targetLink.classList.add('active');
                    this.elements.cifSearchGroup.classList.toggle('d-none', this.state.activeTab !== 'cif');
                    this.elements.customSearchGroup.classList.toggle('d-none', this.state.activeTab !== 'custom');
                    this.renderActiveTabList();
                }
            });

            this.elements.cifSearchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
            this.elements.customSearchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
            
            // [NÂNG CẤP] Sử dụng selectionchange để bắt vị trí con trỏ một cách đáng tin cậy hơn
            this.elements.docPreview.addEventListener('keyup', () => this.saveLastSelection());
            this.elements.docPreview.addEventListener('mouseup', () => this.saveLastSelection());
            this.elements.docPreview.addEventListener('focus', () => this.saveLastSelection());
        },

        saveLastSelection() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && this.elements.docPreview.contains(selection.anchorNode)) {
                this.state.lastSelection = selection.getRangeAt(0).cloneRange();
            }
        },
        
        // --- UI RENDERING ---
        renderActiveTabList() {
            const searchTerm = (this.state.activeTab === 'cif' ? this.elements.cifSearchInput.value : this.elements.customSearchInput.value).toLowerCase();
            let fieldsToRender = this.state.activeTab === 'cif'
                ? allAvailableFields.filter(f => f.dataSourceType === 'CIF')
                : this.state.customFields;

            if (searchTerm) {
                fieldsToRender = fieldsToRender.filter(f => 
                    f.name.toLowerCase().includes(searchTerm) || 
                    (f.displayName && f.displayName.toLowerCase().includes(searchTerm))
                );
            }
            
            const listHtml = fieldsToRender.length > 0
                ? fieldsToRender.map(field => this.createFieldItemHtml(field)).join('')
                : '<div class="p-4 text-center text-muted">Không có trường nào.</div>';

            this.elements.fieldsListContainer.innerHTML = listHtml;
        },

        handleSearch(term) {
            this.renderActiveTabList();
        },

        createFieldItemHtml(field) {
            const dataTypeUpper = (field.dataType || "TEXT").toUpperCase();
            let iconClass = "ti ti-abc text-muted";
            if (dataTypeUpper.includes("DATE")) { iconClass = "ti ti-calendar-event text-danger"; }
            else if (dataTypeUpper.includes("NUMBER")) { iconClass = "ti ti-number-123 text-success"; }
            else if (dataTypeUpper.includes("TEXTAREA")) { iconClass = "ti ti-forms text-info"; }
            
            const dataSourceBadge = field.dataSourceType ? `<span class="badge bg-${field.dataSourceType === 'CIF' ? 'primary' : 'yellow'}-lt d-block mt-1">${field.dataSourceType}</span>` : '';

            return `
                <div class="field-item p-2 border-bottom" data-field-name="${field.name}" data-display-name="${field.displayName}">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="field-item-display">
                            <div style="text-align:center; width: 40px;">
                                <i class="${iconClass} field-data-type-icon" title="${field.dataType}"></i>
                                ${dataSourceBadge}
                            </div>
                            <div class="field-item-info">
                                <div class="fw-bold field-item-name" title="${field.name}">${field.name}</div>
                                <div class="text-muted small" title="${field.displayName}">${field.displayName ?? field.name}</div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary insert-field-btn" data-field-code="${field.name}" data-field-name="${field.displayName}" title="Chèn">
                            <i class="ti ti-arrow-right"></i>
                        </button>
                    </div>
                </div>`;
        },
        
        // [NÂNG CẤP] Render danh sách trường đã chèn từ mảng fingerprint
        updateInsertedFieldsUI() {
            // 1. Nhóm các fingerprint theo fieldName để đếm số lượng
            const groupedByField = this.state.mappedFieldsFingerprints.reduce((acc, fp) => {
                if (!acc[fp.fieldName]) {
                    acc[fp.fieldName] = 0;
                }
                acc[fp.fieldName]++;
                return acc;
            }, {});

            const insertedFieldNames = Object.keys(groupedByField);
            this.elements.insertedCount.textContent = insertedFieldNames.length;

            if (insertedFieldNames.length === 0) {
                this.elements.insertedList.innerHTML = `<div class="p-4 text-center text-muted">Chưa có trường nào.</div>`;
                return;
            }

            // 2. Render HTML
            let html = '<div class="list-group list-group-flush">';
            insertedFieldNames.sort().forEach(fieldName => {
                const count = groupedByField[fieldName];
                const fieldInfo = availableFieldsMap.get(fieldName);
                const displayName = fieldInfo?.displayName || fieldName;
                const dataType = fieldInfo?.dataType || 'TEXT';
                const dataSourceType = fieldInfo?.dataSourceType || '';
                const iconClass = (dataType.toUpperCase().includes('DATE')) ? 'ti ti-calendar-event text-danger' 
                : (dataType.toUpperCase().includes('NUMBER')) ? 'ti ti-number-123 text-success' 
                : (dataType.toUpperCase().includes('TEXTAREA')) ? 'ti ti-forms text-info'
                : 'ti ti-abc text-muted';
                const dataSourceBadge = dataSourceType ? `<span class="badge bg-${dataSourceType === 'CIF' ? 'primary' : 'yellow'}-lt d-block mt-1">${dataSourceType}</span>` : '';

                html += `
                    <div class="field-item list-group-item p-2">
                        <div class="d-flex align-items-center justify-content-between">
                            <div class="field-item-display">
                                <div style="text-align:center; width: 40px;">
                                    <i class="${iconClass} field-data-type-icon" title="${dataType}"></i>
                                    ${dataSourceBadge}
                                </div>
                                <div class="field-item-info">
                                    <div class="fw-bold field-item-name" title="${fieldName}">${fieldName}</div>
                                    <div class="text-muted small" title="${displayName}">${displayName}</div>
                                </div>
                            </div>
                            <div class="d-flex align-items-center ms-2">
                                <span class="badge bg-secondary-lt me-2">SL: ${count}</span>
                                <button type="button" class="btn btn-sm btn-icon btn-outline-danger btn-remove-field" data-field="${fieldName}" title="Xóa tất cả các lần chèn của trường này">
                                    <i class="ti ti-x"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
            });
            html += '</div>';
            this.elements.insertedList.innerHTML = html;
        },

        // --- EVENT HANDLING ---
        handleGlobalClick(e) {
            const target = e.target;
            const insertBtn = target.closest('.insert-field-btn');
            const removeBtn = target.closest('.btn-remove-field');
            const clearAllBtn = target.closest('#clearAllFields');
            const saveBtn = target.closest('#saveMappingBtn');
            const createBtn = target.closest('#showCreateFieldModalBtn');
            const saveCustomBtn = target.closest('#saveCustomFieldBtn');
            const placeholder = target.closest('.field-placeholder');

            if (insertBtn) {
                const fieldName = insertBtn.dataset.fieldCode;
                const displayName = insertBtn.dataset.fieldName;
                this.handleInsertField(fieldName, displayName);
            } else if (removeBtn) {
                const fieldName = removeBtn.dataset.field;
                this.modal.show({
                    title: 'Xóa trường',
                    message: `Bạn có chắc muốn xóa tất cả các lần chèn của trường <strong>${fieldName}</strong> không?`,
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.removeField(fieldName)
                });
            } else if (clearAllBtn) {
                this.modal.show({
                    title: 'Xóa tất cả?',
                    message: 'Hành động này sẽ xóa tất cả các trường đã chèn. Bạn có chắc không?',
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.removeField(null, true)
                });
            } else if (saveBtn) {
                this.handleSave();
            } else if (createBtn) {
                this.state.createFieldModal.show();
            } else if (saveCustomBtn) {
                this.handleSaveCustomField();
            } else if (placeholder) {
                e.preventDefault(); e.stopPropagation();
                const safeText = this.escapeHtml(placeholder.textContent);
                this.modal.show({
                    title: 'Xóa placeholder?',
                    message: `Bạn có chắc muốn xóa placeholder <strong>${safeText}</strong> này không?`,
                    type: 'danger',
                    confirmText: 'Đồng ý',
                    showCancel: true,
                    onConfirm: () => this.handleRemovePlaceholder(placeholder)
                });
            }
        },
        
        // --- CORE LOGIC ---

        handleSaveCustomField() {
            const nameInput = document.getElementById('modalFieldName');
            const displayNameInput = document.getElementById('modalDisplayName');
            const dataTypeInput = document.getElementById('modalDataType');

            const name = nameInput.value.trim();
            const displayName = displayNameInput.value.trim();
            const dataType = dataTypeInput.value;

            if (!name || !displayName) {
                this.modal.show({ title: 'Lỗi', message: 'Tên trường và Tên hiển thị là bắt buộc.', type: 'danger' });
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(name)) {
                this.modal.show({ title: 'Lỗi', message: 'Tên trường chỉ được chứa chữ cái, số và dấu gạch dưới, không chứa khoảng trắng.', type: 'danger' });
                return;
            }

            if (availableFieldsMap.has(name)) {
                this.modal.show({ title: 'Lỗi', message: `Tên trường "${name}" đã tồn tại. Vui lòng chọn tên khác.`, type: 'danger' });
                return;
            }

            const newField = {
                name: name,
                displayName: displayName,
                dataType: dataType,
                dataSourceType: 'FORM'
            };

            this.state.customFields.push(newField);
            availableFieldsMap.set(name, newField);
            
            if (this.state.activeTab === 'custom') {
                this.renderActiveTabList();
            }

            this.state.createFieldModal.hide();
            
            nameInput.value = '';
            displayNameInput.value = '';
            dataTypeInput.value = 'TEXT';
        },

        handleInsertField(fieldName, displayName) {
            if (!this.state.lastSelection) {
                this.modal.show({ title: 'Cần chọn vị trí', message: 'Vui lòng chọn vị trí trong tài liệu trước khi chèn placeholder.', type: 'warning' });
                return;
            }
            
            const range = this.state.lastSelection;
            const fingerprint = this.createFingerprintFromRange(range, fieldName);
            
            if (!fingerprint) {
                this.modal.show({ title: 'Lỗi', message: 'Không thể tạo "dấu vân tay" cho vị trí này. Vui lòng thử lại ở vị trí khác.', type: 'danger' });
                return;
            }

            // Thêm fingerprint vào mảng state
            this.state.mappedFieldsFingerprints.push(fingerprint);

            // Chèn node vào UI
            this.insertPlaceholderNode(range, fieldName, displayName, fingerprint.uiId);
            
            // Cập nhật lại danh sách bên phải
            this.updateInsertedFieldsUI();
            this.initTooltips();
        },

        // [NÂNG CẤP] Xóa một placeholder cụ thể
        handleRemovePlaceholder(placeholderElement) {
            const uiId = placeholderElement.dataset.uiId;
            if (uiId) {
                // Lọc mảng state để loại bỏ fingerprint có uiId tương ứng
                this.state.mappedFieldsFingerprints = this.state.mappedFieldsFingerprints.filter(p => p.uiId !== uiId);
            }
            
            const parent = placeholderElement.parentElement;
            placeholderElement.remove();
            parent.normalize(); // Gộp các text node lại nếu có
            this.updateInsertedFieldsUI();
        },
        
        // [NÂNG CẤP] Xóa tất cả các lần chèn của một trường, hoặc xóa tất cả
        removeField(fieldName, clearAll = false) {
            if (clearAll) {
                this.elements.docPreview.querySelectorAll('.field-placeholder').forEach(el => el.remove());
                this.state.mappedFieldsFingerprints = [];
            } else if (fieldName) {
                this.elements.docPreview.querySelectorAll(`.field-placeholder[data-field-name="${fieldName}"]`).forEach(el => el.remove());
                this.state.mappedFieldsFingerprints = this.state.mappedFieldsFingerprints.filter(fp => fp.fieldName !== fieldName);
            }
            this.updateInsertedFieldsUI();
        },

        handleSave() {
            this.modal.show({
                title: 'Xác nhận lưu',
                message: 'Bạn có chắc chắn muốn lưu các thay đổi này không?',
                type: 'primary',
                confirmText: 'Đồng ý',
                showCancel: true,
                onConfirm: async () => {
                    // This callback now runs *after* the confirmation modal is hidden.
                    this.state.loadingModal.show();
                    
                    const mappedFieldNames = [...new Set(this.state.mappedFieldsFingerprints.map(f => f.fieldName))];
                    
                    const fieldsInfo = mappedFieldNames.map(fieldName => {
                        const field = availableFieldsMap.get(fieldName);
                        if (field) {
                            return {
                                Name: field.name,
                                DataType: field.dataType || 'TEXT',
                                DataSourceType: field.dataSourceType || 'FORM',
                                DisplayName: field.displayName || field.name,
                                DisplayOrder: field.displayOrder || 0
                            };
                        }
                        return null;
                    }).filter(Boolean);
                    
                    const requestPayload = {
                        templateId: this.state.templateId,
                        fingerprints: this.state.mappedFieldsFingerprints.map(({ uiId, ...rest }) => rest),
                        fields: fieldsInfo
                    };
                    
                    try {
                        const response = await fetch('@Url.Action("SaveMapping", "Template")', {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify(requestPayload)
                        });
                        
                        const result = await response.json();

                        await new Promise(resolve => {
                            const loadingModalEl = document.getElementById('loadingModal');
                            loadingModalEl.addEventListener('hidden.bs.modal', resolve, { once: true });
                            this.state.loadingModal.hide();
                        });
                        
                        if (response.ok && result.success) {
                            this.modal.show({ title: 'Thành công', message: result.message, type: 'success', isNotification: true });
                        } else {
                            this.modal.show({ title: 'Lỗi', message: result.message || 'Lưu thất bại.', type: 'danger', isNotification: true });
                        }

                    } catch (error) {
                        await new Promise(resolve => {
                            const loadingModalEl = document.getElementById('loadingModal');
                            loadingModalEl.addEventListener('hidden.bs.modal', resolve, { once: true });
                            this.state.loadingModal.hide();
                        });

                        this.modal.show({ title: 'Lỗi nghiêm trọng', message: 'Đã có lỗi xảy ra: ' + error.message, type: 'danger', isNotification: true });
                    }
                }
            });
        },

        // --- FINGERPRINTING HELPERS (HOÀN TOÀN MỚI) ---

        /**
         * [CỐT LÕI MỚI] Tạo đối tượng FieldPositionFingerprint tại vị trí con trỏ.
         */
        createFingerprintFromRange(range, fieldName) {
            const startNode = range.startContainer;

            let pElement = startNode;
            if (pElement.nodeType !== Node.ELEMENT_NODE) {
                pElement = pElement.parentElement;
            }
            while (pElement && pElement.tagName !== 'P') {
                pElement = pElement.parentElement;
            }

            if (!pElement || !pElement.dataset.paragraphId) {
                console.error("Con trỏ không nằm trong một paragraph hợp lệ (thiếu data-paragraph-id).", startNode);
                return null;
            }

            const paragraphId = pElement.dataset.paragraphId;
            const partUri = pElement.dataset.partUri;

            // Tính độ sâu bảng lồng: đọc từ phần tử tổ tiên .nested-table gần nhất
            let nestedDepth = 0;
            const nearestTable = pElement.closest && pElement.closest('.nested-table');
            if (nearestTable && nearestTable.dataset && typeof nearestTable.dataset.nestedDepth !== 'undefined') {
                const parsed = parseInt(nearestTable.dataset.nestedDepth, 10);
                if (!Number.isNaN(parsed)) nestedDepth = parsed;
            }

            // Chuẩn hóa caret về TEXT_NODE gần nhất để tránh trường hợp caret nằm giữa các NODE phần tử
            const { container: normNode, offset: normOffset } = this.normalizeRangeStart(range);
            // Tính offset tuyệt đối và fullText, BỎ QUA text nằm trong .field-placeholder
            const { fullText, absoluteOffset } = this.getParagraphTextAndAbsoluteOffsetExcludingPlaceholders(pElement, normNode, normOffset);
            const offsetInParagraph = absoluteOffset;
            
            const contextBeforeText = fullText.substring(Math.max(0, offsetInParagraph - 20), offsetInParagraph);
            const contextAfterText = fullText.substring(offsetInParagraph, offsetInParagraph + 20);

            // Gán tie-breaker theo vị trí caret so với các placeholder đã có cùng paragraphId + offsetInParagraph
            const siblingsAtSameSpot = this.state.mappedFieldsFingerprints.filter(fp => fp.paragraphId === paragraphId && fp.offsetInParagraph === offsetInParagraph);

            let offsetTieBreaker = 0;
            if (siblingsAtSameSpot.length === 0) {
                offsetTieBreaker = 0;
            } else {
                // Ghép cặp placeholder DOM với tie-breaker để so vị trí
                const pairs = siblingsAtSameSpot
                    .map(fp => ({ el: this.elements.docPreview.querySelector(`.field-placeholder[data-ui-id="${fp.uiId}"]`), tb: fp.offsetTieBreaker }))
                    .filter(p => !!p.el && typeof p.tb === 'number');

                // Phân loại theo vị trí so với caret
                const left = [];
                const right = [];
                for (const p of pairs) {
                    const phRange = document.createRange();
                    phRange.setStartBefore(p.el);
                    phRange.collapse(true);
                    const cmp = range.compareBoundaryPoints(Range.START_TO_START, phRange);
                    if (cmp > 0) left.push(p);      // caret sau placeholder => placeholder ở bên trái caret
                    else right.push(p);             // caret trước/đúng vị trí => placeholder ở bên phải hoặc trùng
                }

                const maxLeft = left.length ? Math.max(...left.map(p => p.tb)) : null;
                const minRight = right.length ? Math.min(...right.map(p => p.tb)) : null;

                if (maxLeft !== null && minRight !== null) {
                    // Chèn lọt giữa hai bên: lấy trung điểm
                    offsetTieBreaker = (maxLeft + minRight) / 2;
                    // Nếu vô tình trùng do precision, nới nhẹ 1e-6
                    if (offsetTieBreaker === maxLeft || offsetTieBreaker === minRight) offsetTieBreaker = maxLeft + (minRight - maxLeft) / 2 + 1e-6;
                } else if (maxLeft !== null) {
                    // Không có bên phải: append sau cùng
                    offsetTieBreaker = maxLeft + 1;
                } else if (minRight !== null) {
                    // Không có bên trái: chèn trước cùng
                    offsetTieBreaker = minRight - 1;
                } else {
                    // Không tìm thấy DOM (hiếm): fallback dựa trên danh sách hiện có
                    const existingTbs = siblingsAtSameSpot
                        .map(fp => typeof fp.offsetTieBreaker === 'number' ? fp.offsetTieBreaker : null)
                        .filter(v => v !== null);
                    if (existingTbs.length) {
                        offsetTieBreaker = Math.max(...existingTbs) + 1;
                    } else {
                        offsetTieBreaker = 0;
                    }
                }
            }

            return {
                uiId: crypto.randomUUID(), // ID tạm thời để quản lý trên UI
                fieldName: fieldName,
                partUri: partUri,
                paragraphId: paragraphId,
                offsetInParagraph: offsetInParagraph,
                offsetTieBreaker: offsetTieBreaker,
                nestedDepth: nestedDepth,
                contextBeforeText: contextBeforeText,
                contextAfterText: contextAfterText
            };
        },

        /**
         * [CỐT LÕI MỚI] Tính toán vị trí offset của con trỏ trong văn bản thuần túy của paragraph.
         */
        calculateOffsetInParagraph(parentElement, range) {
            const { startContainer, startOffset } = range;
            let accumulatedOffset = 0;
            let foundCaret = false;

            function traverseNodes(node) {
                if (foundCaret) return;

                if (node.nodeType === Node.TEXT_NODE) {
                    if (node === startContainer) {
                        accumulatedOffset += startOffset;
                        foundCaret = true;
                    } else {
                        accumulatedOffset += node.textContent.length;
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('field-placeholder')) {
                    for (const childNode of node.childNodes) {
                        traverseNodes(childNode);
                        if (foundCaret) break;
                    }
                }
            }

            traverseNodes(parentElement);
            return accumulatedOffset;
        },

        insertPlaceholderNode(range, fieldName, displayName, uiId) {
            // [GIỮ NGUYÊN] Logic tạo và chèn node span vào DOM
            const placeholderEl = document.createElement('span');
            placeholderEl.className = 'field-placeholder';
            placeholderEl.contentEditable = 'false';
            placeholderEl.dataset.fieldName = fieldName;
            placeholderEl.dataset.uiId = uiId;
            placeholderEl.textContent = `<<${fieldName}>>`;
            placeholderEl.dataset.bsToggle = 'tooltip';
            placeholderEl.title = `Click để xóa Field: ${displayName || fieldName}`;

            range.deleteContents();
            range.insertNode(placeholderEl);
            
            const selection = window.getSelection();
            range.setStartAfter(placeholderEl);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            this.state.lastSelection = range.cloneRange();
        },

        // [NÂNG CẤP] Khôi phục lại các placeholder trên UI từ mảng fingerprint
        restorePlaceholdersOnUI() {
            // 1. Nhóm các fingerprint theo paragraphId để xử lý hiệu quả
            const fingerprintsByParagraph = this.state.mappedFieldsFingerprints.reduce((acc, fp) => {
                if (!acc[fp.paragraphId]) {
                    acc[fp.paragraphId] = [];
                }
                acc[fp.paragraphId].push(fp);
                return acc;
            }, {});

            // 2. Duyệt qua từng paragraph có fingerprint
            for (const paragraphId in fingerprintsByParagraph) {
                const targetParagraph = this.elements.docPreview.querySelector(`p[data-paragraph-id="${paragraphId}"]`);
                if (!targetParagraph) {
                    console.warn("Không tìm thấy paragraph để khôi phục:", paragraphId);
                    continue;
                }

                // 3. Sắp xếp các fingerprint trong paragraph theo:
                //    3.1 offset GIẢM DẦN (để chèn từ cuối lên đầu)
                //    3.2 tie-breaker GIẢM DẦN cho các fingerprint cùng offset (đảm bảo kết quả cuối cùng theo thứ tự tăng dần tie-breaker)
                const sortedFingerprints = fingerprintsByParagraph[paragraphId]
                    .slice()
                    .sort((a, b) => {
                        if (b.offsetInParagraph !== a.offsetInParagraph) return b.offsetInParagraph - a.offsetInParagraph;
                        const tbA = (typeof a.offsetTieBreaker === 'number') ? a.offsetTieBreaker : Number.NEGATIVE_INFINITY;
                        const tbB = (typeof b.offsetTieBreaker === 'number') ? b.offsetTieBreaker : Number.NEGATIVE_INFINITY;
                        return tbB - tbA; // chèn cái có tie-breaker lớn trước
                    });
                
                // 4. Chèn từng placeholder
                for (const fingerprint of sortedFingerprints) {
                    const position = this.findNodeAndOffsetFromAbsolute(targetParagraph, fingerprint.offsetInParagraph);
                    if (position.node) {
                        const range = document.createRange();
                        range.setStart(position.node, position.offset);
                        const fieldInfo = availableFieldsMap.get(fingerprint.fieldName);
                        this.insertPlaceholderNode(range, fingerprint.fieldName, fieldInfo?.displayName || fingerprint.fieldName, fingerprint.uiId);
                    } else {
                        console.warn("Không tìm thấy vị trí node để khôi phục placeholder:", fingerprint);
                    }
                }
            }
        },

        /**
         * [CỐT LÕI MỚI] Tìm node và vị trí offset trong node đó từ một vị trí offset tuyệt đối trong paragraph.
         */
        findNodeAndOffsetFromAbsolute(paragraph, absoluteOffset) {
            const walker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    // Bỏ qua text nằm bên trong placeholder để vị trí không bị lệch
                    if (node.parentElement && node.parentElement.closest && node.parentElement.closest('.field-placeholder')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            let cumulativeOffset = 0;
            let currentNode;
            while (currentNode = walker.nextNode()) {
                const nodeLength = currentNode.textContent.length;
                if (cumulativeOffset + nodeLength >= absoluteOffset) {
                    const offsetInNode = absoluteOffset - cumulativeOffset;
                    return { node: currentNode, offset: offsetInNode };
                }
                cumulativeOffset += nodeLength;
            }
            
            // Fallback: nếu offset nằm ở cuối cùng
            const allTextNodes = [];
            const treeWalker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (node.parentElement && node.parentElement.closest && node.parentElement.closest('.field-placeholder')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            while(treeWalker.nextNode()) allTextNodes.push(treeWalker.currentNode);
            const lastTextNode = allTextNodes.length > 0 ? allTextNodes[allTextNodes.length - 1] : null;
            if(lastTextNode) {
                 return { node: lastTextNode, offset: lastTextNode.textContent.length };
            }

            // Fallback cho paragraph hoàn toàn trống
            if (!paragraph.hasChildNodes()) {
                const emptyTextNode = document.createTextNode('');
                paragraph.appendChild(emptyTextNode);
                return { node: emptyTextNode, offset: 0 };
            }

            return { node: paragraph.childNodes[paragraph.childNodes.length - 1], offset: (paragraph.childNodes[paragraph.childNodes.length - 1].textContent || '').length };
        },
        
        normalizeRangeStart(range) {
            let container = range.startContainer;
            let offset = range.startOffset;

            if (container.nodeType !== Node.TEXT_NODE) {
                let targetNode = container;
                if (targetNode.nodeType === Node.ELEMENT_NODE && offset < targetNode.childNodes.length) {
                    targetNode = targetNode.childNodes[offset];
                }

                const walker = document.createTreeWalker(targetNode, NodeFilter.SHOW_TEXT);
                const firstTextNode = walker.nextNode();

                if (firstTextNode) {
                    container = firstTextNode;
                    offset = 0;
                } else {
                    const tempTextNode = document.createTextNode('');
                    range.insertNode(tempTextNode);
                    container = tempTextNode;
                    offset = 0;
                }
            }
            return { container, offset };
        },

        getParagraphTextAndAbsoluteOffsetExcludingPlaceholders(paragraph, startNode, startOffset) {
            let fullText = '';
            let absoluteOffset = -1;

            const walker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    // Loại trừ text nằm bên trong placeholder
                    if (node.parentElement && node.parentElement.closest && node.parentElement.closest('.field-placeholder')) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                }
            });

            let currentNode;
            while (currentNode = walker.nextNode()) {
                if (absoluteOffset === -1 && currentNode === startNode) {
                    absoluteOffset = fullText.length + startOffset;
                }
                fullText += currentNode.textContent;
            }

            // Nếu không khớp đúng node bắt đầu (trường hợp hiếm), chốt về cuối fullText
            if (absoluteOffset === -1 && paragraph.contains(startNode)) {
                absoluteOffset = fullText.length;
            }

            return { fullText, absoluteOffset };
        },
        
        
        // --- UTILITIES ---
        initTooltips() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(el => {
                const instance = bootstrap.Tooltip.getInstance(el);
                if (instance) instance.dispose();
                new bootstrap.Tooltip(el);
            });
        },
        escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        },

        modal: {
            instance: null,
            titleEl: null,
            messageEl: null,
            iconEl: null,
            confirmBtn: null,
            cancelBtn: null,
            onConfirmCallback: null,

            // =================================================================
            // SỬA LỖI: Bắt đầu phần sửa lỗi hiển thị modal
            // =================================================================
            init() {
                const modalEl = document.getElementById('customModal');
                if (!modalEl) return;
                this.instance = new bootstrap.Modal(modalEl);
                this.titleEl = document.getElementById('modalTitle');
                this.messageEl = document.getElementById('modalMessage');
                this.iconEl = document.getElementById('modalIcon');
                this.confirmBtn = document.getElementById('modalConfirmBtn');
                this.cancelBtn = document.getElementById('modalCancelBtn');

                this.confirmBtn.addEventListener('click', () => {
                    // First, hide the current modal.
                    this.instance.hide();
                    
                    // Then, if a callback exists, attach it to the 'hidden' event
                    // to ensure it runs *after* the modal is fully closed, preventing race conditions.
                    if (typeof this.onConfirmCallback === 'function') {
                        // A stable reference is needed because `this.onConfirmCallback`
                        // might be changed by another call to `show()` before this event fires.
                        const callbackToRun = this.onConfirmCallback;
                        modalEl.addEventListener('hidden.bs.modal', callbackToRun, { once: true });
                    }
                });
            },

            show({ title, message, type = 'primary', confirmText = 'OK', showCancel = false, onConfirm = null, isNotification = false }) {
                this.titleEl.textContent = title;
                this.messageEl.innerHTML = message;
                
                this.iconEl.className = `ti mb-2 text-${type}`;
                if (type === 'danger') this.iconEl.classList.add('ti-alert-triangle');
                else if (type === 'success') this.iconEl.classList.add('ti-check');
                else this.iconEl.classList.add('ti-info-circle');

                if (isNotification) {
                    // Notification Mode: Only show one "Close" button.
                    this.confirmBtn.style.display = 'none';
                    
                    this.cancelBtn.textContent = 'Đóng';
                    this.cancelBtn.className = 'btn btn-primary w-100'; // Use primary color for visibility
                    this.cancelBtn.style.display = 'block';
                } else {
                    // Confirmation/Action Mode (original behavior)
                    this.confirmBtn.style.display = 'block';
                    this.confirmBtn.textContent = confirmText;
                    this.confirmBtn.className = `btn btn-${type}`;
                    
                    this.cancelBtn.textContent = 'Hủy'; // Reset text
                    this.cancelBtn.className = 'btn btn-secondary'; // Reset class
                    this.cancelBtn.style.display = showCancel ? 'block' : 'none';

                    if (showCancel) {
                        this.confirmBtn.classList.remove('w-100');
                    } else {
                        this.confirmBtn.classList.add('w-100');
                    }
                }

                this.onConfirmCallback = onConfirm;
                
                this.instance.show();
            }
            // =================================================================
            // SỬA LỖI: Kết thúc phần sửa lỗi hiển thị modal
            // =================================================================
        },
        
        protection: {
            warningTimeout: null,
            
            init() {
                const docPreview = App.elements.docPreview;
                if (!docPreview) return;

                docPreview.addEventListener('keydown', (e) => {
                    const allowedKeys = [
                        'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
                        'Home', 'End', 'PageUp', 'PageDown', 'Tab', 'Escape'
                    ];
                    if (e.ctrlKey && (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'c')) {
                        return;
                    }
                    
                    if (!allowedKeys.includes(e.key)) {
                        e.preventDefault();
                        this.showEditWarning();
                    }
                });
                
                docPreview.addEventListener('paste', (e) => { 
                    e.preventDefault(); 
                    this.showEditWarning();
                });
                
                docPreview.addEventListener('drop', (e) => { 
                    e.preventDefault(); 
                    this.showEditWarning();
                });
            },

            showEditWarning() {
                const docPreview = App.elements.docPreview;
                docPreview.style.backgroundColor = '#fff3cd';
                docPreview.style.outline = '2px solid #ffeaa7';

                clearTimeout(this.warningTimeout);
                this.warningTimeout = setTimeout(() => {
                    docPreview.style.backgroundColor = '';
                    docPreview.style.outline = '';
                }, 500);
            }
        }
    };

    App.init();
});
</script>
}
